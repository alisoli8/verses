
import { GoogleGenAI, Type } from "@google/genai";
import type { VsPost } from '../types';

if (!process.env.API_KEY) {
  // In a real app, you might provide a mock service or disable the feature.
  // For this context, we'll log a warning and let it fail at runtime if used.
  console.warn("API_KEY environment variable not set. AI features will not work.");
}

const ai = new GoogleGenAI({ apiKey: process.env.API_KEY! });

const textModel = 'gemini-2.5-flash';
const imageModel = 'imagen-3.0-generate-002';

const vsPostSchema = {
    type: Type.OBJECT,
    properties: {
        title: {
            type: Type.STRING,
            description: "A creative and exciting title for the VS matchup. Should be catchy, like a movie title."
        },
        optionA_name: {
            type: Type.STRING,
            description: "The name of the first competitor."
        },
        optionB_name: {
            type: Type.STRING,
            description: "The name of the second competitor."
        }
    },
    required: ["title", "optionA_name", "optionB_name"]
};

const generateVsText = async (topic: string): Promise<{ title: string; optionA_name: string; optionB_name: string }> => {
  try {
    const prompt = `Create a "versus" matchup based on the topic: "${topic}". The two options should be clear competitors or interesting opposites. Generate a catchy title for this matchup.`;

    const response = await ai.models.generateContent({
      model: textModel,
      contents: prompt,
      config: {
        responseMimeType: "application/json",
        responseSchema: vsPostSchema,
        thinkingConfig: { thinkingBudget: 0 }
      },
    });

    const jsonText = response.text.trim();
    const parsed = JSON.parse(jsonText);
    
    if (parsed && typeof parsed.title === 'string' && typeof parsed.optionA_name === 'string' && typeof parsed.optionB_name === 'string') {
        return parsed;
    } else {
        throw new Error("Invalid JSON structure received from AI.");
    }
  } catch (error) {
    console.error("Error generating VS text:", error);
    throw new Error("Failed to generate matchup text. The AI might be having a moment.");
  }
};

export const generateImage = async (name: string, topic: string): Promise<string> => {
    try {
        const prompt = `For a competition about '${topic}', generate an iconic, high-quality, cinematic image that is a powerful visual representation of '${name}'. The image must be directly related to '${name}' and avoid generic scenery. For example, if the name is 'The Matrix', the image should feature elements like green code, Neo, or Trinity, not a random forest. The style should be dramatic and visually appealing. Vertical 3:4 aspect ratio.`;
        
        const response = await ai.models.generateImages({
            model: imageModel,
            prompt: prompt,
            config: {
                numberOfImages: 1,
                outputMimeType: 'image/jpeg',
                aspectRatio: '3:4',
            },
        });

        if (response.generatedImages && response.generatedImages.length > 0 && response.generatedImages[0].image?.imageBytes) {
            const base64ImageBytes = response.generatedImages[0].image.imageBytes;
            return `data:image/jpeg;base64,${base64ImageBytes}`;
        } else {
            throw new Error("No image generated by the API.");
        }
    } catch (error) {
        console.error(`Error generating image for "${name}":`, error);
        return `https://picsum.photos/seed/${name.replace(/\s+/g, '-')}/600/800`;
    }
};

export const generateNewVsPost = async (topic: string): Promise<Omit<VsPost, 'id' | 'userVote' | 'author' | 'comments'>> => {
    const textData = await generateVsText(topic);
    
    const [imageUrlA, imageUrlB] = await Promise.all([
        generateImage(textData.optionA_name, topic),
        generateImage(textData.optionB_name, topic),
    ]);

    return {
        type: 'classic',
        title: textData.title,
        topic: topic,
        optionA: {
            name: textData.optionA_name,
            imageUrl: imageUrlA,
            votes: 0,
        },
        optionB: {
            name: textData.optionB_name,
            imageUrl: imageUrlB,
            votes: 0,
        },
        likes: 0,
        shares: 0,
    };
};